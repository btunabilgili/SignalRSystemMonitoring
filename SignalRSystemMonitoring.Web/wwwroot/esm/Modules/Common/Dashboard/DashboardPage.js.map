{
  "version": 3,
  "sources": ["../../../../../Modules/Common/Dashboard/DashboardPage.ts", "../../../../../node_modules/@microsoft/signalr/src/Errors.ts", "../../../../../node_modules/@microsoft/signalr/src/HttpClient.ts", "../../../../../node_modules/@microsoft/signalr/src/ILogger.ts", "../../../../../node_modules/@microsoft/signalr/src/Loggers.ts", "../../../../../node_modules/@microsoft/signalr/src/Utils.ts", "../../../../../node_modules/@microsoft/signalr/src/FetchHttpClient.ts", "../../../../../node_modules/@microsoft/signalr/src/XhrHttpClient.ts", "../../../../../node_modules/@microsoft/signalr/src/DefaultHttpClient.ts", "../../../../../node_modules/@microsoft/signalr/src/TextMessageFormat.ts", "../../../../../node_modules/@microsoft/signalr/src/HandshakeProtocol.ts", "../../../../../node_modules/@microsoft/signalr/src/IHubProtocol.ts", "../../../../../node_modules/@microsoft/signalr/src/Subject.ts", "../../../../../node_modules/@microsoft/signalr/src/HubConnection.ts", "../../../../../node_modules/@microsoft/signalr/src/DefaultReconnectPolicy.ts", "../../../../../node_modules/@microsoft/signalr/src/HeaderNames.ts", "../../../../../node_modules/@microsoft/signalr/src/AccessTokenHttpClient.ts", "../../../../../node_modules/@microsoft/signalr/src/ITransport.ts", "../../../../../node_modules/@microsoft/signalr/src/AbortController.ts", "../../../../../node_modules/@microsoft/signalr/src/LongPollingTransport.ts", "../../../../../node_modules/@microsoft/signalr/src/ServerSentEventsTransport.ts", "../../../../../node_modules/@microsoft/signalr/src/WebSocketTransport.ts", "../../../../../node_modules/@microsoft/signalr/src/HttpConnection.ts", "../../../../../node_modules/@microsoft/signalr/src/JsonHubProtocol.ts", "../../../../../node_modules/@microsoft/signalr/src/HubConnectionBuilder.ts"],
  "sourcesContent": ["import { TemplatedPanel } from \"@serenity-is/corelib\";\r\n//import { ErrorHandling, isEmptyOrNull, notifyError, parseQueryString, resolveUrl, serviceCall, ServiceResponse, localText, htmlEncode } from \"@serenity-is/corelib/q\";\r\nimport { HubConnection, HubConnectionBuilder } from \"@microsoft/signalr\"\r\n\r\n$(function () {\r\n    new DashboardPanel($('#dashboard-container'));\r\n});\r\n\r\nclass DashboardPanel extends TemplatedPanel<any> {\r\n    private _hubConnection: HubConnection;\r\n\r\n    constructor(container: JQuery) {\r\n        super(container);\r\n\r\n        this.element.append(`<div class=\"cpu\"></div>`);\r\n        this.element.append(`<div class=\"total-memory\"></div>`);\n        this.element.append(`<div class=\"memory\"></div>`);\r\n\r\n        this._hubConnection = new HubConnectionBuilder()\r\n            .withUrl('/SystemHealth')\r\n            .build();\r\n\r\n        this._hubConnection.on('testing', (data) => {\r\n            this.element.find(\".cpu\").html(\"CPU: \" + data.cpu);\r\n            this.element.find(\".total-memory\").html(\"Total Memory: \" + data.totalMemory);\n            this.element.find(\".memory\").html(\"Memory: \" + data.memory);\r\n        });\r\n\r\n        this._hubConnection.start().catch(err => console.error(err.toString()));\r\n    }\r\n\r\n    protected getTemplate() {\r\n        return `<div>I am here</div>`;\r\n    }\r\n}", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpTransportType } from \"./ITransport\";\r\n\r\n/** Error thrown when an HTTP request fails. */\r\nexport class HttpError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The HTTP status code represented by this error. */\r\n    public statusCode: number;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     * @param {number} statusCode The HTTP status code represented by this error.\r\n     */\r\n    constructor(errorMessage: string, statusCode: number) {\r\n        const trueProto = new.target.prototype;\r\n        super(`${errorMessage}: Status code '${statusCode}'`);\r\n        this.statusCode = statusCode;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when a timeout elapses. */\r\nexport class TimeoutError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"A timeout occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when an action is aborted. */\r\nexport class AbortError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** Constructs a new instance of {@link AbortError}.\r\n     *\r\n     * @param {string} errorMessage A descriptive error message.\r\n     */\r\n    constructor(errorMessage: string = \"An abort occurred.\") {\r\n        const trueProto = new.target.prototype;\r\n        super(errorMessage);\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is unsupported by the browser. */\r\n/** @private */\r\nexport class UnsupportedTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'UnsupportedTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport is disabled by the browser. */\r\n/** @private */\r\nexport class DisabledTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'DisabledTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the selected transport cannot be started. */\r\n/** @private */\r\nexport class FailedToStartTransportError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The {@link @microsoft/signalr.HttpTransportType} this error occurred on. */\r\n    public transport: HttpTransportType;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\r\n     */\r\n    constructor(message: string, transport: HttpTransportType) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.transport = transport;\r\n        this.errorType = 'FailedToStartTransportError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when the negotiation with the server failed to complete. */\r\n/** @private */\r\nexport class FailedToNegotiateWithServerError extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The type name of this error. */\r\n    public errorType: string;\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     */\r\n    constructor(message: string) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n        this.errorType = 'FailedToNegotiateWithServerError';\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n\r\n/** Error thrown when multiple errors have occurred. */\r\n/** @private */\r\nexport class AggregateErrors extends Error {\r\n    // @ts-ignore: Intentionally unused.\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private __proto__: Error;\r\n\r\n    /** The collection of errors this error is aggregating. */\r\n    public innerErrors: Error[];\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\r\n     *\r\n     * @param {string} message A descriptive error message.\r\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\r\n     */\r\n    constructor(message: string, innerErrors: Error[]) {\r\n        const trueProto = new.target.prototype;\r\n        super(message);\r\n\r\n        this.innerErrors = innerErrors;\r\n\r\n        // Workaround issue in Typescript compiler\r\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\r\n        this.__proto__ = trueProto;\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortSignal } from \"./AbortController\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\n\r\n/** Represents an HTTP request. */\r\nexport interface HttpRequest {\r\n    /** The HTTP method to use for the request. */\r\n    method?: string;\r\n\r\n    /** The URL for the request. */\r\n    url?: string;\r\n\r\n    /** The body content for the request. May be a string or an ArrayBuffer (for binary data). */\r\n    content?: string | ArrayBuffer;\r\n\r\n    /** An object describing headers to apply to the request. */\r\n    headers?: MessageHeaders;\r\n\r\n    /** The XMLHttpRequestResponseType to apply to the request. */\r\n    responseType?: XMLHttpRequestResponseType;\r\n\r\n    /** An AbortSignal that can be monitored for cancellation. */\r\n    abortSignal?: AbortSignal;\r\n\r\n    /** The time to wait for the request to complete before throwing a TimeoutError. Measured in milliseconds. */\r\n    timeout?: number;\r\n\r\n    /** This controls whether credentials such as cookies are sent in cross-site requests. */\r\n    withCredentials?: boolean;\r\n}\r\n\r\n/** Represents an HTTP response. */\r\nexport class HttpResponse {\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     */\r\n    constructor(statusCode: number);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code and message.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and string content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: ArrayBuffer);\r\n\r\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpResponse} with the specified status code, message and binary content.\r\n     *\r\n     * @param {number} statusCode The status code of the response.\r\n     * @param {string} statusText The status message of the response.\r\n     * @param {string | ArrayBuffer} content The content of the response.\r\n     */\r\n    constructor(statusCode: number, statusText: string, content: string | ArrayBuffer);\r\n    constructor(\r\n        public readonly statusCode: number,\r\n        public readonly statusText?: string,\r\n        public readonly content?: string | ArrayBuffer) {\r\n    }\r\n}\r\n\r\n/** Abstraction over an HTTP client.\r\n *\r\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\r\n */\r\nexport abstract class HttpClient {\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP GET request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public get(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public get(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"GET\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP POST request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public post(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public post(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"POST\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string): Promise<HttpResponse>;\r\n\r\n    /** Issues an HTTP DELETE request to the specified URL, returning a Promise that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {string} url The URL for the request.\r\n     * @param {HttpRequest} options Additional options to configure the request. The 'url' field in this object will be overridden by the url parameter.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an {@link @microsoft/signalr.HttpResponse} describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public delete(url: string, options: HttpRequest): Promise<HttpResponse>;\r\n    public delete(url: string, options?: HttpRequest): Promise<HttpResponse> {\r\n        return this.send({\r\n            ...options,\r\n            method: \"DELETE\",\r\n            url,\r\n        });\r\n    }\r\n\r\n    /** Issues an HTTP request to the specified URL, returning a {@link Promise} that resolves with an {@link @microsoft/signalr.HttpResponse} representing the result.\r\n     *\r\n     * @param {HttpRequest} request An {@link @microsoft/signalr.HttpRequest} describing the request to send.\r\n     * @returns {Promise<HttpResponse>} A Promise that resolves with an HttpResponse describing the response, or rejects with an Error indicating a failure.\r\n     */\r\n    public abstract send(request: HttpRequest): Promise<HttpResponse>;\r\n\r\n    /** Gets all cookies that apply to the specified URL.\r\n     *\r\n     * @param url The URL that the cookies are valid for.\r\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\r\n     */\r\n    // @ts-ignore\r\n    public getCookieString(url: string): string {\r\n        return \"\";\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\r\n/** Indicates the severity of a log message.\r\n *\r\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\r\n */\r\nexport enum LogLevel {\r\n    /** Log level for very low severity diagnostic messages. */\r\n    Trace = 0,\r\n    /** Log level for low severity diagnostic messages. */\r\n    Debug = 1,\r\n    /** Log level for informational diagnostic messages. */\r\n    Information = 2,\r\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\r\n    Warning = 3,\r\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\r\n    Error = 4,\r\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\r\n    Critical = 5,\r\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\r\n    None = 6,\r\n}\r\n\r\n/** An abstraction that provides a sink for diagnostic messages. */\r\nexport interface ILogger {\r\n    /** Called by the framework to emit a diagnostic message.\r\n     *\r\n     * @param {LogLevel} logLevel The severity level of the message.\r\n     * @param {string} message The message.\r\n     */\r\n    log(logLevel: LogLevel, message: string): void;\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\n\r\n/** A logger that does nothing when log messages are sent to it. */\r\nexport class NullLogger implements ILogger {\r\n    /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\r\n    public static instance: ILogger = new NullLogger();\r\n\r\n    private constructor() {}\r\n\r\n    /** @inheritDoc */\r\n    // eslint-disable-next-line\r\n    public log(_logLevel: LogLevel, _message: string): void {\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n// Version token that will be replaced by the prepack command\r\n/** The version of the SignalR client. */\r\n\r\nexport const VERSION: string = \"0.0.0-DEV_BUILD\";\r\n/** @private */\r\nexport class Arg {\r\n    public static isRequired(val: any, name: string): void {\r\n        if (val === null || val === undefined) {\r\n            throw new Error(`The '${name}' argument is required.`);\r\n        }\r\n    }\r\n    public static isNotEmpty(val: string, name: string): void {\r\n        if (!val || val.match(/^\\s*$/)) {\r\n            throw new Error(`The '${name}' argument should not be empty.`);\r\n        }\r\n    }\r\n\r\n    public static isIn(val: any, values: any, name: string): void {\r\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\r\n        if (!(val in values)) {\r\n            throw new Error(`Unknown ${name} value: ${val}.`);\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class Platform {\r\n    // react-native has a window but no document so we should check both\r\n    public static get isBrowser(): boolean {\r\n        return typeof window === \"object\" && typeof window.document === \"object\";\r\n    }\r\n\r\n    // WebWorkers don't have a window object so the isBrowser check would fail\r\n    public static get isWebWorker(): boolean {\r\n        return typeof self === \"object\" && \"importScripts\" in self;\r\n    }\r\n\r\n    // react-native has a window but no document\r\n    static get isReactNative(): boolean {\r\n        return typeof window === \"object\" && typeof window.document === \"undefined\";\r\n    }\r\n\r\n    // Node apps shouldn't have a window object, but WebWorkers don't either\r\n    // so we need to check for both WebWorker and window\r\n    public static get isNode(): boolean {\r\n        return !this.isBrowser && !this.isWebWorker && !this.isReactNative;\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getDataDetail(data: any, includeContent: boolean): string {\r\n    let detail = \"\";\r\n    if (isArrayBuffer(data)) {\r\n        detail = `Binary data of length ${data.byteLength}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\r\n        }\r\n    } else if (typeof data === \"string\") {\r\n        detail = `String data of length ${data.length}`;\r\n        if (includeContent) {\r\n            detail += `. Content: '${data}'`;\r\n        }\r\n    }\r\n    return detail;\r\n}\r\n\r\n/** @private */\r\nexport function formatArrayBuffer(data: ArrayBuffer): string {\r\n    const view = new Uint8Array(data);\r\n\r\n    // Uint8Array.map only supports returning another Uint8Array?\r\n    let str = \"\";\r\n    view.forEach((num) => {\r\n        const pad = num < 16 ? \"0\" : \"\";\r\n        str += `0x${pad}${num.toString(16)} `;\r\n    });\r\n\r\n    // Trim of trailing space.\r\n    return str.substr(0, str.length - 1);\r\n}\r\n\r\n// Also in signalr-protocol-msgpack/Utils.ts\r\n/** @private */\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}\r\n\r\n/** @private */\r\nexport async function sendMessage(logger: ILogger, transportName: string, httpClient: HttpClient, url: string,\r\n                                  content: string | ArrayBuffer, options: IHttpConnectionOptions): Promise<void> {\r\n    const headers: {[k: string]: string} = {};\r\n\r\n    const [name, value] = getUserAgentHeader();\r\n    headers[name] = value;\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent!)}.`);\r\n\r\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\r\n    const response = await httpClient.post(url, {\r\n        content,\r\n        headers: { ...headers, ...options.headers},\r\n        responseType,\r\n        timeout: options.timeout,\r\n        withCredentials: options.withCredentials,\r\n    });\r\n\r\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\r\n}\r\n\r\n/** @private */\r\nexport function createLogger(logger?: ILogger | LogLevel): ILogger {\r\n    if (logger === undefined) {\r\n        return new ConsoleLogger(LogLevel.Information);\r\n    }\r\n\r\n    if (logger === null) {\r\n        return NullLogger.instance;\r\n    }\r\n\r\n    if ((logger as ILogger).log !== undefined) {\r\n        return logger as ILogger;\r\n    }\r\n\r\n    return new ConsoleLogger(logger as LogLevel);\r\n}\r\n\r\n/** @private */\r\nexport class SubjectSubscription<T> implements ISubscription<T> {\r\n    private _subject: Subject<T>;\r\n    private _observer: IStreamSubscriber<T>;\r\n\r\n    constructor(subject: Subject<T>, observer: IStreamSubscriber<T>) {\r\n        this._subject = subject;\r\n        this._observer = observer;\r\n    }\r\n\r\n    public dispose(): void {\r\n        const index: number = this._subject.observers.indexOf(this._observer);\r\n        if (index > -1) {\r\n            this._subject.observers.splice(index, 1);\r\n        }\r\n\r\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\r\n            this._subject.cancelCallback().catch((_) => { });\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport class ConsoleLogger implements ILogger {\r\n    private readonly _minLevel: LogLevel;\r\n\r\n    // Public for testing purposes.\r\n    public out: {\r\n        error(message: any): void,\r\n        warn(message: any): void,\r\n        info(message: any): void,\r\n        log(message: any): void,\r\n    };\r\n\r\n    constructor(minimumLogLevel: LogLevel) {\r\n        this._minLevel = minimumLogLevel;\r\n        this.out = console;\r\n    }\r\n\r\n    public log(logLevel: LogLevel, message: string): void {\r\n        if (logLevel >= this._minLevel) {\r\n            const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\r\n            switch (logLevel) {\r\n                case LogLevel.Critical:\r\n                case LogLevel.Error:\r\n                    this.out.error(msg);\r\n                    break;\r\n                case LogLevel.Warning:\r\n                    this.out.warn(msg);\r\n                    break;\r\n                case LogLevel.Information:\r\n                    this.out.info(msg);\r\n                    break;\r\n                default:\r\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\r\n                    this.out.log(msg);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getUserAgentHeader(): [string, string] {\r\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\r\n    if (Platform.isNode) {\r\n        userAgentHeaderName = \"User-Agent\";\r\n    }\r\n    return [ userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion()) ];\r\n}\r\n\r\n/** @private */\r\nexport function constructUserAgent(version: string, os: string, runtime: string, runtimeVersion: string | undefined): string {\r\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\r\n    let userAgent: string = \"Microsoft SignalR/\";\r\n\r\n    const majorAndMinor = version.split(\".\");\r\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\r\n    userAgent += ` (${version}; `;\r\n\r\n    if (os && os !== \"\") {\r\n        userAgent += `${os}; `;\r\n    } else {\r\n        userAgent += \"Unknown OS; \";\r\n    }\r\n\r\n    userAgent += `${runtime}`;\r\n\r\n    if (runtimeVersion) {\r\n        userAgent += `; ${runtimeVersion}`;\r\n    } else {\r\n        userAgent += \"; Unknown Runtime Version\";\r\n    }\r\n\r\n    userAgent += \")\";\r\n    return userAgent;\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getOsName(): string {\r\n    if (Platform.isNode) {\r\n        switch (process.platform) {\r\n            case \"win32\":\r\n                return \"Windows NT\";\r\n            case \"darwin\":\r\n                return \"macOS\";\r\n            case \"linux\":\r\n                return \"Linux\";\r\n            default:\r\n                return process.platform;\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line spaced-comment\r\n/*#__PURE__*/ function getRuntimeVersion(): string | undefined {\r\n    if (Platform.isNode) {\r\n        return process.versions.node;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction getRuntime(): string {\r\n    if (Platform.isNode) {\r\n        return \"NodeJS\";\r\n    } else {\r\n        return \"Browser\";\r\n    }\r\n}\r\n\r\n/** @private */\r\nexport function getErrorString(e: any): string {\r\n    if (e.stack) {\r\n        return e.stack;\r\n    } else if (e.message) {\r\n        return e.message;\r\n    }\r\n    return `${e}`;\r\n}\r\n\r\n/** @private */\r\nexport function getGlobalThis(): unknown {\r\n    // globalThis is semi-new and not available in Node until v12\r\n    if (typeof globalThis !== \"undefined\") {\r\n        return globalThis;\r\n    }\r\n    if (typeof self !== \"undefined\") {\r\n        return self;\r\n    }\r\n    if (typeof window !== \"undefined\") {\r\n        return window;\r\n    }\r\n    if (typeof global !== \"undefined\") {\r\n        return global;\r\n    }\r\n    throw new Error(\"could not find global\");\r\n}", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport { CookieJar } from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis, isArrayBuffer } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly _abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly _fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly _jar?: CookieJar;\r\n\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        } else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this._abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        if (request.content === \"\") {\r\n            request.content = undefined;\r\n        }\r\n        if (request.content) {\r\n            // Explicitly setting the Content-Type header for React Native on Android platform.\r\n            request.headers = request.headers || {};\r\n            if (isArrayBuffer(request.content)) {\r\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\r\n            } else {\r\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\r\n            }\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this._fetchType(request.url!, {\r\n                body: request.content,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\") as string;\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\nexport class XhrHttpClient extends HttpClient {\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n\r\n            xhr.open(request.method!, request.url!, true);\r\n            xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\r\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\r\n            if (request.content === \"\") {\r\n                request.content = undefined;\r\n            }\r\n            if (request.content) {\r\n                // Explicitly setting the Content-Type header for React Native on Android platform.\r\n                if (isArrayBuffer(request.content)) {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\r\n                } else {\r\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\r\n                }\r\n            }\r\n\r\n            const headers = request.headers;\r\n            if (headers) {\r\n                Object.keys(headers)\r\n                    .forEach((header) => {\r\n                        xhr.setRequestHeader(header, headers[header]);\r\n                    });\r\n            }\r\n\r\n            if (request.responseType) {\r\n                xhr.responseType = request.responseType;\r\n            }\r\n\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = () => {\r\n                    xhr.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n\r\n            if (request.timeout) {\r\n                xhr.timeout = request.timeout;\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (request.abortSignal) {\r\n                    request.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\r\n                } else {\r\n                    reject(new HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => {\r\n                this._logger.log(LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\r\n                reject(new HttpError(xhr.statusText, xhr.status));\r\n            };\r\n\r\n            xhr.ontimeout = () => {\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                reject(new TimeoutError());\r\n            };\r\n\r\n            xhr.send(request.content);\r\n        });\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortError } from \"./Errors\";\r\nimport { FetchHttpClient } from \"./FetchHttpClient\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\nimport { XhrHttpClient } from \"./XhrHttpClient\";\r\n\r\n/** Default implementation of {@link @microsoft/signalr.HttpClient}. */\r\nexport class DefaultHttpClient extends HttpClient {\r\n    private readonly _httpClient: HttpClient;\r\n\r\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n\r\n        if (typeof fetch !== \"undefined\" || Platform.isNode) {\r\n            this._httpClient = new FetchHttpClient(logger);\r\n        } else if (typeof XMLHttpRequest !== \"undefined\") {\r\n            this._httpClient = new XhrHttpClient(logger);\r\n        } else {\r\n            throw new Error(\"No usable HttpClient found.\");\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            return Promise.reject(new AbortError());\r\n        }\r\n\r\n        if (!request.method) {\r\n            return Promise.reject(new Error(\"No method defined.\"));\r\n        }\r\n        if (!request.url) {\r\n            return Promise.reject(new Error(\"No url defined.\"));\r\n        }\r\n\r\n        return this._httpClient.send(request);\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._httpClient.getCookieString(url);\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Not exported from index\r\n/** @private */\r\nexport class TextMessageFormat {\r\n    public static RecordSeparatorCode = 0x1e;\r\n    public static RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\r\n\r\n    public static write(output: string): string {\r\n        return `${output}${TextMessageFormat.RecordSeparator}`;\r\n    }\r\n\r\n    public static parse(input: string): string[] {\r\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\r\n            throw new Error(\"Message is incomplete.\");\r\n        }\r\n\r\n        const messages = input.split(TextMessageFormat.RecordSeparator);\r\n        messages.pop();\r\n        return messages;\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\n/** @private */\r\nexport interface HandshakeRequestMessage {\r\n    readonly protocol: string;\r\n    readonly version: number;\r\n}\r\n\r\n/** @private */\r\nexport interface HandshakeResponseMessage {\r\n    readonly error: string;\r\n    readonly minorVersion: number;\r\n}\r\n\r\n/** @private */\r\nexport class HandshakeProtocol {\r\n    // Handshake request is always JSON\r\n    public writeHandshakeRequest(handshakeRequest: HandshakeRequestMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(handshakeRequest));\r\n    }\r\n\r\n    public parseHandshakeResponse(data: any): [any, HandshakeResponseMessage] {\r\n        let messageData: string;\r\n        let remainingData: any;\r\n\r\n        if (isArrayBuffer(data)) {\r\n            // Format is binary but still need to read JSON text from handshake response\r\n            const binaryData = new Uint8Array(data);\r\n            const separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\r\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\r\n        } else {\r\n            const textData: string = data;\r\n            const separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);\r\n            if (separatorIndex === -1) {\r\n                throw new Error(\"Message is incomplete.\");\r\n            }\r\n\r\n            // content before separator is handshake response\r\n            // optional content after is additional messages\r\n            const responseLength = separatorIndex + 1;\r\n            messageData = textData.substring(0, responseLength);\r\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\r\n        }\r\n\r\n        // At this point we should have just the single handshake message\r\n        const messages = TextMessageFormat.parse(messageData);\r\n        const response = JSON.parse(messages[0]);\r\n        if (response.type) {\r\n            throw new Error(\"Expected a handshake response from the server.\");\r\n        }\r\n        const responseMessage: HandshakeResponseMessage = response;\r\n\r\n        // multiple messages could have arrived with handshake\r\n        // return additional data to be parsed as usual, or null if all parsed\r\n        return [remainingData, responseMessage];\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { ILogger } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\n\r\n/** Defines the type of a Hub Message. */\r\nexport enum MessageType {\r\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\r\n    Invocation = 1,\r\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\r\n    StreamItem = 2,\r\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\r\n    Completion = 3,\r\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\r\n    StreamInvocation = 4,\r\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\r\n    CancelInvocation = 5,\r\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\r\n    Ping = 6,\r\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\r\n    Close = 7,\r\n}\r\n\r\n/** Defines a dictionary of string keys and string values representing headers attached to a Hub message. */\r\nexport interface MessageHeaders {\r\n    /** Gets or sets the header with the specified key. */\r\n    [key: string]: string;\r\n}\r\n\r\n/** Union type of all known Hub messages. */\r\nexport type HubMessage =\r\n    InvocationMessage |\r\n    StreamInvocationMessage |\r\n    StreamItemMessage |\r\n    CompletionMessage |\r\n    CancelInvocationMessage |\r\n    PingMessage |\r\n    CloseMessage;\r\n\r\n/** Defines properties common to all Hub messages. */\r\nexport interface HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageType} value indicating the type of this message. */\r\n    readonly type: MessageType;\r\n}\r\n\r\n/** Defines properties common to all Hub messages relating to a specific invocation. */\r\nexport interface HubInvocationMessage extends HubMessageBase {\r\n    /** A {@link @microsoft/signalr.MessageHeaders} dictionary containing headers attached to the message. */\r\n    readonly headers?: MessageHeaders;\r\n    /** The ID of the invocation relating to this message.\r\n     *\r\n     * This is expected to be present for {@link @microsoft/signalr.StreamInvocationMessage} and {@link @microsoft/signalr.CompletionMessage}. It may\r\n     * be 'undefined' for an {@link @microsoft/signalr.InvocationMessage} if the sender does not expect a response.\r\n     */\r\n    readonly invocationId?: string;\r\n}\r\n\r\n/** A hub message representing a non-streaming invocation. */\r\nexport interface InvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Invocation;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a streaming invocation. */\r\nexport interface StreamInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamInvocation;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The target method name. */\r\n    readonly target: string;\r\n    /** The target method arguments. */\r\n    readonly arguments: any[];\r\n    /** The target methods stream IDs. */\r\n    readonly streamIds?: string[];\r\n}\r\n\r\n/** A hub message representing a single item produced as part of a result stream. */\r\nexport interface StreamItemMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.StreamItem;\r\n\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n\r\n    /** The item produced by the server. */\r\n    readonly item?: any;\r\n}\r\n\r\n/** A hub message representing the result of an invocation. */\r\nexport interface CompletionMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Completion;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n    /** The error produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly error?: string;\r\n    /** The result produced by the invocation, if any.\r\n     *\r\n     * Either {@link @microsoft/signalr.CompletionMessage.error} or {@link @microsoft/signalr.CompletionMessage.result} must be defined, but not both.\r\n     */\r\n    readonly result?: any;\r\n}\r\n\r\n/** A hub message indicating that the sender is still active. */\r\nexport interface PingMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Ping;\r\n}\r\n\r\n/** A hub message indicating that the sender is closing the connection.\r\n *\r\n * If {@link @microsoft/signalr.CloseMessage.error} is defined, the sender is closing the connection due to an error.\r\n */\r\nexport interface CloseMessage extends HubMessageBase {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.Close;\r\n    /** The error that triggered the close, if any.\r\n     *\r\n     * If this property is undefined, the connection was closed normally and without error.\r\n     */\r\n    readonly error?: string;\r\n\r\n    /** If true, clients with automatic reconnects enabled should attempt to reconnect after receiving the CloseMessage. Otherwise, they should not. */\r\n    readonly allowReconnect?: boolean;\r\n}\r\n\r\n/** A hub message sent to request that a streaming invocation be canceled. */\r\nexport interface CancelInvocationMessage extends HubInvocationMessage {\r\n    /** @inheritDoc */\r\n    readonly type: MessageType.CancelInvocation;\r\n    /** The invocation ID. */\r\n    readonly invocationId: string;\r\n}\r\n\r\n/** A protocol abstraction for communicating with SignalR Hubs.  */\r\nexport interface IHubProtocol {\r\n    /** The name of the protocol. This is used by SignalR to resolve the protocol between the client and server. */\r\n    readonly name: string;\r\n    /** The version of the protocol. */\r\n    readonly version: number;\r\n    /** The {@link @microsoft/signalr.TransferFormat} of the protocol. */\r\n    readonly transferFormat: TransferFormat;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the `input` parameter must be a string, otherwise it must be an ArrayBuffer.\r\n     *\r\n     * @param {string | ArrayBuffer} input A string or ArrayBuffer containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    parseMessages(input: string | ArrayBuffer, logger: ILogger): HubMessage[];\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string or ArrayBuffer and returns it.\r\n     *\r\n     * If {@link @microsoft/signalr.IHubProtocol.transferFormat} is 'Text', the result of this method will be a string, otherwise it will be an ArrayBuffer.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string | ArrayBuffer} A string or ArrayBuffer containing the serialized representation of the message.\r\n     */\r\n    writeMessage(message: HubMessage): string | ArrayBuffer;\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IStreamResult, IStreamSubscriber, ISubscription } from \"./Stream\";\r\nimport { SubjectSubscription } from \"./Utils\";\r\n\r\n/** Stream implementation to stream items to the server. */\r\nexport class Subject<T> implements IStreamResult<T> {\r\n    /** @internal */\r\n    public observers: IStreamSubscriber<T>[];\r\n\r\n    /** @internal */\r\n    public cancelCallback?: () => Promise<void>;\r\n\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n\r\n    public next(item: T): void {\r\n        for (const observer of this.observers) {\r\n            observer.next(item);\r\n        }\r\n    }\r\n\r\n    public error(err: any): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.error) {\r\n                observer.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    public complete(): void {\r\n        for (const observer of this.observers) {\r\n            if (observer.complete) {\r\n                observer.complete();\r\n            }\r\n        }\r\n    }\r\n\r\n    public subscribe(observer: IStreamSubscriber<T>): ISubscription<T> {\r\n        this.observers.push(observer);\r\n        return new SubjectSubscription(this, observer);\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { AbortError } from \"./Errors\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg, getErrorString, Platform } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly _cachedPingMessage: string | ArrayBuffer;\r\n    // Needs to not start with _ for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private readonly connection: IConnection;\r\n    private readonly _logger: ILogger;\r\n    private readonly _reconnectPolicy?: IRetryPolicy;\r\n    private _protocol: IHubProtocol;\r\n    private _handshakeProtocol: HandshakeProtocol;\r\n    private _callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private _methods: { [name: string]: (((...args: any[]) => void) | ((...args: any[]) => any))[] };\r\n    private _invocationId: number;\r\n\r\n    private _closedCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectingCallbacks: ((error?: Error) => void)[];\r\n    private _reconnectedCallbacks: ((connectionId?: string) => void)[];\r\n\r\n    private _receivedHandshakeResponse: boolean;\r\n    private _handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private _handshakeRejecter!: (reason?: any) => void;\r\n    private _stopDuringStartError?: Error;\r\n\r\n    private _connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private _startPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _nextKeepAlive: number = 0;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private _reconnectDelayHandle?: any;\r\n    private _timeoutHandle?: any;\r\n    private _pingServerHandle?: any;\r\n\r\n    private _freezeEventListener = () =>\r\n    {\r\n        this._logger.log(LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\r\n    };\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     * The ping will happen at most as often as the server pings.\r\n     * If the server pings every 5 seconds, a value lower than 5 will ping every 5 seconds.\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this._logger = logger;\r\n        this._protocol = protocol;\r\n        this.connection = connection;\r\n        this._reconnectPolicy = reconnectPolicy;\r\n        this._handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this._processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this._connectionClosed(error);\r\n\r\n        this._callbacks = {};\r\n        this._methods = {};\r\n        this._closedCallbacks = [];\r\n        this._reconnectingCallbacks = [];\r\n        this._reconnectedCallbacks = [];\r\n        this._invocationId = 0;\r\n        this._receivedHandshakeResponse = false;\r\n        this._connectionState = HubConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n\r\n        this._cachedPingMessage = this._protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this._connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this._startPromise = this._startWithStateTransitions();\r\n        return this._startPromise;\r\n    }\r\n\r\n    private async _startWithStateTransitions(): Promise<void> {\r\n        if (this._connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Connecting;\r\n        this._logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this._startInternal();\r\n\r\n            if (Platform.isBrowser) {\r\n                // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\r\n                window.document.addEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            this._connectionState = HubConnectionState.Connected;\r\n            this._connectionStarted = true;\r\n            this._logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _startInternal() {\r\n        this._stopDuringStartError = undefined;\r\n        this._receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this._handshakeResolver = resolve;\r\n            this._handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this._protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this._protocol.name,\r\n                version: this._protocol.version,\r\n            };\r\n\r\n            this._logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this._logger.log(LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this._cleanupTimeout();\r\n            this._resetTimeoutPeriod();\r\n            this._resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this._stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                // eslint-disable-next-line @typescript-eslint/no-throw-literal\r\n                throw this._stopDuringStartError;\r\n            }\r\n\r\n            if (!this.connection.features.inherentKeepAlive) {\r\n                await this._sendMessage(this._cachedPingMessage);\r\n            }\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this._cleanupTimeout();\r\n            this._cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this._startPromise;\r\n\r\n        this._stopPromise = this._stopInternal();\r\n        await this._stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private _stopInternal(error?: Error): Promise<void> {\r\n        if (this._connectionState === HubConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise!;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this._logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this._reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this._logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this._reconnectDelayHandle);\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            this._completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n        this._stopDuringStartError = error || new AbortError(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\r\n\r\n        // eslint-disable-next-line prefer-const\r\n        let promiseQueue: Promise<void>;\r\n\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this._createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this._callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this._sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this._callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this._launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private _sendMessage(message: any) {\r\n        this._resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private _sendWithProtocol(message: any) {\r\n        return this._sendMessage(this._protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\r\n\r\n        this._launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this._replaceStreamingParams(args);\r\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this._callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this._callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this._launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => any): void\r\n    public on(methodName: string, newMethod: (...args: any[]) => void): void {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this._methods[methodName]) {\r\n            this._methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this._methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this._methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this._methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this._methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void): void {\r\n        if (callback) {\r\n            this._reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void): void {\r\n        if (callback) {\r\n            this._reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private _processIncomingData(data: any) {\r\n        this._cleanupTimeout();\r\n\r\n        if (!this._receivedHandshakeResponse) {\r\n            data = this._processHandshakeResponse(data);\r\n            this._receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this._protocol.parseMessages(data, this._logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                        this._invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion: {\r\n                        const callback = this._callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this._callbacks[message.invocationId];\r\n                            }\r\n                            try {\r\n                                callback(message);\r\n                            } catch (e) {\r\n                                this._logger.log(LogLevel.Error, `Stream callback threw error: ${getErrorString(e)}`);\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close: {\r\n                        this._logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this._stopPromise = this._stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                    default:\r\n                        this._logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._resetTimeoutPeriod();\r\n    }\r\n\r\n    private _processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this._handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this._handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private _resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n\r\n        this._cleanupPingTimer();\r\n    }\r\n\r\n    private _resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n\r\n            // Set keepAlive timer if there isn't one\r\n            if (this._pingServerHandle === undefined)\r\n            {\r\n                let nextPing = this._nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this._pingServerHandle = setTimeout(async () => {\r\n                    if (this._connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this._sendMessage(this._cachedPingMessage);\r\n                        } catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this._cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private async _invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methodName = invocationMessage.target.toLowerCase();\r\n        const methods = this._methods[methodName];\r\n        if (!methods) {\r\n            this._logger.log(LogLevel.Warning, `No client method with the name '${methodName}' found.`);\r\n\r\n            // No handlers provided by client but the server is expecting a response still, so we send an error\r\n            if (invocationMessage.invocationId) {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\r\n        const methodsCopy = methods.slice();\r\n\r\n        // Server expects a response\r\n        const expectsResponse = invocationMessage.invocationId ? true : false;\r\n        // We preserve the last result or exception but still call all handlers\r\n        let res;\r\n        let exception;\r\n        let completionMessage;\r\n        for (const m of methodsCopy) {\r\n            try {\r\n                const prevRes = res;\r\n                res = await m.apply(this, invocationMessage.arguments);\r\n                if (expectsResponse && res && prevRes) {\r\n                    this._logger.log(LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\r\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `Client provided multiple results.`, null);\r\n                }\r\n                // Ignore exception if we got a result after, the exception will be logged\r\n                exception = undefined;\r\n            } catch (e) {\r\n                exception = e;\r\n                this._logger.log(LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\r\n            }\r\n        }\r\n        if (completionMessage) {\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else if (expectsResponse) {\r\n            // If there is an exception that means either no result was given or a handler after a result threw\r\n            if (exception) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, `${exception}`, null);\r\n            } else if (res !== undefined) {\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, null, res);\r\n            } else {\r\n                this._logger.log(LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\r\n                // Client didn't provide a result or throw from a handler, server expects a response so we send an error\r\n                completionMessage = this._createCompletionMessage(invocationMessage.invocationId!, \"Client didn't provide a result.\", null);\r\n            }\r\n            await this._sendWithProtocol(completionMessage);\r\n        } else {\r\n            if (res) {\r\n                this._logger.log(LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _connectionClosed(error?: Error) {\r\n        this._logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this._stopDuringStartError = this._stopDuringStartError || error || new AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this._handshakeResolver) {\r\n            this._handshakeResolver();\r\n        }\r\n\r\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this._cleanupTimeout();\r\n        this._cleanupPingTimer();\r\n\r\n        if (this._connectionState === HubConnectionState.Disconnecting) {\r\n            this._completeClose(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._reconnect(error);\r\n        } else if (this._connectionState === HubConnectionState.Connected) {\r\n            this._completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private _completeClose(error?: Error) {\r\n        if (this._connectionStarted) {\r\n            this._connectionState = HubConnectionState.Disconnected;\r\n            this._connectionStarted = false;\r\n\r\n            if (Platform.isBrowser) {\r\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\r\n            }\r\n\r\n            try {\r\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this._logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this._completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this._connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this._reconnectingCallbacks.length !== 0) {\r\n            try {\r\n                this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this._logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this._reconnectDelayHandle = undefined;\r\n\r\n            if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                this._logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this._startInternal();\r\n\r\n                this._connectionState = HubConnectionState.Connected;\r\n                this._logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this._reconnectedCallbacks.length !== 0) {\r\n                    try {\r\n                        this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this._logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\r\n                    this._logger.log(LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this._connectionState as any === HubConnectionState.Disconnecting) {\r\n                        this._completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this._logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this._completeClose();\r\n    }\r\n\r\n    private _getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this._reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private _cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this._callbacks;\r\n        this._callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                try {\r\n                    callback(null, error);\r\n                } catch (e) {\r\n                    this._logger.log(LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`);\r\n                }\r\n            });\r\n    }\r\n\r\n    private _cleanupPingTimer(): void {\r\n        if (this._pingServerHandle) {\r\n            clearTimeout(this._pingServerHandle);\r\n            this._pingServerHandle = undefined;\r\n        }\r\n    }\r\n\r\n    private _cleanupTimeout(): void {\r\n        if (this._timeoutHandle) {\r\n            clearTimeout(this._timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private _createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this._invocationId;\r\n            this._invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private _launchStreams(streams: IStreamResult<any>[], promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private _replaceStreamingParams(args: any[]): [IStreamResult<any>[], string[]] {\r\n        const streams: IStreamResult<any>[] = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this._isObservable(argument)) {\r\n                const streamId = this._invocationId;\r\n                this._invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private _isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private _createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this._invocationId;\r\n        this._invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private _createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private _createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private _createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { IRetryPolicy, RetryContext } from \"./IRetryPolicy\";\r\n\r\n// 0, 2, 10, 30 second delays before reconnect attempts.\r\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\r\n\r\n/** @private */\r\nexport class DefaultReconnectPolicy implements IRetryPolicy {\r\n    private readonly _retryDelays: (number | null)[];\r\n\r\n    constructor(retryDelays?: number[]) {\r\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\r\n    }\r\n\r\n    public nextRetryDelayInMilliseconds(retryContext: RetryContext): number | null {\r\n        return this._retryDelays[retryContext.previousRetryCount];\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nexport abstract class HeaderNames {\r\n    static readonly Authorization = \"Authorization\";\r\n    static readonly Cookie = \"Cookie\";\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\n\r\n/** @private */\r\nexport class AccessTokenHttpClient extends HttpClient {\r\n    private _innerClient: HttpClient;\r\n    _accessToken: string | undefined;\r\n    _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n\r\n    constructor(innerClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined) {\r\n        super();\r\n\r\n        this._innerClient = innerClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n    }\r\n\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        let allowRetry = true;\r\n        if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\r\n            // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\r\n            allowRetry = false;\r\n            this._accessToken = await this._accessTokenFactory();\r\n        }\r\n        this._setAuthorizationHeader(request);\r\n        const response = await this._innerClient.send(request);\r\n\r\n        if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\r\n            this._accessToken = await this._accessTokenFactory();\r\n            this._setAuthorizationHeader(request);\r\n            return await this._innerClient.send(request);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    private _setAuthorizationHeader(request: HttpRequest) {\r\n        if (!request.headers) {\r\n            request.headers = {};\r\n        }\r\n        if (this._accessToken) {\r\n            request.headers[HeaderNames.Authorization] = `Bearer ${this._accessToken}`\r\n        }\r\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\r\n        else if (this._accessTokenFactory) {\r\n            if (request.headers[HeaderNames.Authorization]) {\r\n                delete request.headers[HeaderNames.Authorization];\r\n            }\r\n        }\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this._innerClient.getCookieString(url);\r\n    }\r\n}", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\r\n/** Specifies a specific HTTP transport type. */\r\nexport enum HttpTransportType {\r\n    /** Specifies no transport preference. */\r\n    None = 0,\r\n    /** Specifies the WebSockets transport. */\r\n    WebSockets = 1,\r\n    /** Specifies the Server-Sent Events transport. */\r\n    ServerSentEvents = 2,\r\n    /** Specifies the Long Polling transport. */\r\n    LongPolling = 4,\r\n}\r\n\r\n/** Specifies the transfer format for a connection. */\r\nexport enum TransferFormat {\r\n    /** Specifies that only text data will be transmitted over the connection. */\r\n    Text = 1,\r\n    /** Specifies that binary data will be transmitted over the connection. */\r\n    Binary = 2,\r\n}\r\n\r\n/** An abstraction over the behavior of transports. This is designed to support the framework and not intended for use by applications. */\r\nexport interface ITransport {\r\n    connect(url: string, transferFormat: TransferFormat): Promise<void>;\r\n    send(data: any): Promise<void>;\r\n    stop(): Promise<void>;\r\n    onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    onclose: ((error?: Error) => void) | null;\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\r\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\r\n// it's a very new API right now.\r\n\r\n// Not exported from index.\r\n/** @private */\r\nexport class AbortController implements AbortSignal {\r\n    private _isAborted: boolean = false;\r\n    public onabort: (() => void) | null = null;\r\n\r\n    public abort(): void {\r\n        if (!this._isAborted) {\r\n            this._isAborted = true;\r\n            if (this.onabort) {\r\n                this.onabort();\r\n            }\r\n        }\r\n    }\r\n\r\n    get signal(): AbortSignal {\r\n        return this;\r\n    }\r\n\r\n    get aborted(): boolean {\r\n        return this._isAborted;\r\n    }\r\n}\r\n\r\n/** Represents a signal that can be monitored to determine if a request has been aborted. */\r\nexport interface AbortSignal {\r\n    /** Indicates if the request has been aborted. */\r\n    aborted: boolean;\r\n    /** Set this to a handler that will be invoked when the request is aborted. */\r\n    onabort: (() => void) | null;\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AbortController } from \"./AbortController\";\r\nimport { HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n// Not exported from 'index', this type is internal.\r\n/** @private */\r\nexport class LongPollingTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private readonly _pollAbort: AbortController;\r\n\r\n    private _url?: string;\r\n    private _running: boolean;\r\n    private _receiving?: Promise<void>;\r\n    private _closeError?: Error;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    // This is an internal type, not exported from 'index' so this is really just internal.\r\n    public get pollAborted(): boolean {\r\n        return this._pollAbort.aborted;\r\n    }\r\n\r\n    constructor(httpClient: HttpClient, logger: ILogger, options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._logger = logger;\r\n        this._pollAbort = new AbortController();\r\n        this._options = options;\r\n\r\n        this._running = false;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._url = url;\r\n\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n        // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n        if (transferFormat === TransferFormat.Binary &&\r\n            (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n            throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        const headers = { [name]: value, ...this._options.headers };\r\n\r\n        const pollOptions: HttpRequest = {\r\n            abortSignal: this._pollAbort.signal,\r\n            headers,\r\n            timeout: 100000,\r\n            withCredentials: this._options.withCredentials,\r\n        };\r\n\r\n        if (transferFormat === TransferFormat.Binary) {\r\n            pollOptions.responseType = \"arraybuffer\";\r\n        }\r\n\r\n        // Make initial long polling request\r\n        // Server uses first long polling request to finish initializing connection and it returns without data\r\n        const pollUrl = `${url}&_=${Date.now()}`;\r\n        this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n        const response = await this._httpClient.get(pollUrl, pollOptions);\r\n        if (response.statusCode !== 200) {\r\n            this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n            // Mark running as false so that the poll immediately ends and runs the close logic\r\n            this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n            this._running = false;\r\n        } else {\r\n            this._running = true;\r\n        }\r\n\r\n        this._receiving = this._poll(this._url, pollOptions);\r\n    }\r\n\r\n    private async _poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n        try {\r\n            while (this._running) {\r\n                try {\r\n                    const pollUrl = `${url}&_=${Date.now()}`;\r\n                    this._logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n                    const response = await this._httpClient.get(pollUrl, pollOptions);\r\n\r\n                    if (response.statusCode === 204) {\r\n                        this._logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n                        this._running = false;\r\n                    } else if (response.statusCode !== 200) {\r\n                        this._logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n                        // Unexpected status code\r\n                        this._closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n                        this._running = false;\r\n                    } else {\r\n                        // Process the response\r\n                        if (response.content) {\r\n                            this._logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this._options.logMessageContent!)}.`);\r\n                            if (this.onreceive) {\r\n                                this.onreceive(response.content);\r\n                            }\r\n                        } else {\r\n                            // This is another way timeout manifest.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    if (!this._running) {\r\n                        // Log but disregard errors that occur after stopping\r\n                        this._logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n                    } else {\r\n                        if (e instanceof TimeoutError) {\r\n                            // Ignore timeouts and reissue the poll.\r\n                            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n                        } else {\r\n                            // Close the connection with the error as the result.\r\n                            this._closeError = e;\r\n                            this._running = false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n            if (!this.pollAborted) {\r\n                this._raiseOnClose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._running) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"LongPolling\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public async stop(): Promise<void> {\r\n        this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n        // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n        this._running = false;\r\n        this._pollAbort.abort();\r\n\r\n        try {\r\n            await this._receiving;\r\n\r\n            // Send DELETE to clean up long polling on the server\r\n            this._logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\r\n\r\n            const headers: {[k: string]: string} = {};\r\n            const [name, value] = getUserAgentHeader();\r\n            headers[name] = value;\r\n\r\n            const deleteOptions: HttpRequest = {\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            };\r\n            await this._httpClient.delete(this._url!, deleteOptions);\r\n\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n        } finally {\r\n            this._logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n            // Raise close event here instead of in polling\r\n            // It needs to happen after the DELETE request is sent\r\n            this._raiseOnClose();\r\n        }\r\n    }\r\n\r\n    private _raiseOnClose() {\r\n        if (this.onclose) {\r\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n            if (this._closeError) {\r\n                logMessage += \" Error: \" + this._closeError;\r\n            }\r\n            this._logger.log(LogLevel.Trace, logMessage);\r\n            this.onclose(this._closeError);\r\n        }\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\n\r\n/** @private */\r\nexport class ServerSentEventsTransport implements ITransport {\r\n    private readonly _httpClient: HttpClient;\r\n    private readonly _accessToken: string | undefined;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    private _eventSource?: EventSource;\r\n    private _url?: string;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessToken: string | undefined, logger: ILogger,\r\n                options: IHttpConnectionOptions) {\r\n        this._httpClient = httpClient;\r\n        this._accessToken = accessToken;\r\n        this._logger = logger;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n        // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n\r\n        if (this._accessToken) {\r\n            url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n\r\n            let eventSource: EventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials });\r\n            } else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers: MessageHeaders = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                eventSource = new this._options.EventSource!(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers} } as EventSourceInit);\r\n            }\r\n\r\n            try {\r\n                eventSource.onmessage = (e: MessageEvent) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent!)}.`);\r\n                            this.onreceive(e.data);\r\n                        } catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e: Event) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    } else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            } catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async send(data: any): Promise<void> {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url!, data, this._options);\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(e?: Error) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        let token: string;\r\n        if (this._accessTokenFactory) {\r\n            token = await this._accessTokenFactory();\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode || Platform.isReactNative) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                if (token) {\r\n                    headers[HeaderNames.Authorization] = `Bearer ${token}`;\r\n                }\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = cookies;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n            else\r\n            {\r\n                if (token) {\r\n                    url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n                }\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { AccessTokenHttpClient } from \"./AccessTokenHttpClient\";\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { AggregateErrors, DisabledTransportError, FailedToNegotiateWithServerError, FailedToStartTransportError, HttpError, UnsupportedTransportError, AbortError } from \"./Errors\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: (keyof typeof TransferFormat)[];\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private _connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private _connectionStarted: boolean;\r\n    private readonly _httpClient: AccessTokenHttpClient;\r\n    private readonly _logger: ILogger;\r\n    private readonly _options: IHttpConnectionOptions;\r\n    // Needs to not start with _ to be available for tests\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    private transport?: ITransport;\r\n    private _startInternalPromise?: Promise<void>;\r\n    private _stopPromise?: Promise<void>;\r\n    private _stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private _stopError?: Error;\r\n    private _accessTokenFactory?: () => string | Promise<string>;\r\n    private _sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly _negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this._logger = createLogger(options.logger);\r\n        this.baseUrl = this._resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this._httpClient = new AccessTokenHttpClient(options.httpClient || new DefaultHttpClient(this._logger), options.accessTokenFactory);\r\n        this._connectionState = ConnectionState.Disconnected;\r\n        this._connectionStarted = false;\r\n        this._options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this._logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this._connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Connecting;\r\n\r\n        this._startInternalPromise = this._startInternal(transferFormat);\r\n        await this._startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this._connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this._logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this._stopPromise;\r\n\r\n            return Promise.reject(new AbortError(message));\r\n        } else if (this._connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this._logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new AbortError(message));\r\n        }\r\n\r\n        this._connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this._connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this._sendQueue) {\r\n            this._sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this._sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this._stopPromise;\r\n        }\r\n\r\n        this._connectionState = ConnectionState.Disconnecting;\r\n\r\n        this._stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this._stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this._stopInternal(error);\r\n        await this._stopPromise;\r\n    }\r\n\r\n    private async _stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this._stopError = error;\r\n\r\n        try {\r\n            await this._startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this._stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this._logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async _startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this._accessTokenFactory = this._options.accessTokenFactory;\r\n        this._httpClient._accessTokenFactory = this._accessTokenFactory;\r\n\r\n        try {\r\n            if (this._options.skipNegotiation) {\r\n                if (this._options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this._constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this._startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this._getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this._connectionState === ConnectionState.Disconnecting || this._connectionState === ConnectionState.Disconnected) {\r\n                        throw new AbortError(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this._accessTokenFactory = () => accessToken;\r\n                        // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\r\n                        this._httpClient._accessToken = accessToken;\r\n                        this._httpClient._accessTokenFactory = undefined;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this._connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this._logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this._connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this._logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this._connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this._stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async _getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers: {[k: string]: string} = {};\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this._resolveNegotiateUrl(url);\r\n        this._logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this._httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this._options.headers },\r\n                timeout: this._options.timeout,\r\n                withCredentials: this._options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            let errorMessage = \"Failed to complete negotiation with the server: \" + e;\r\n            if (e instanceof HttpError) {\r\n                if (e.statusCode === 404) {\r\n                    errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\r\n                }\r\n            }\r\n            this._logger.log(LogLevel.Error, errorMessage);\r\n\r\n            return Promise.reject(new FailedToNegotiateWithServerError(errorMessage));\r\n        }\r\n    }\r\n\r\n    private _createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async _createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this._isITransport(requestedTransport)) {\r\n            this._logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this._startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed:`);\r\n                transportExceptions.push(transportOrError);\r\n            } else if (this._isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this._getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this._startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this._logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, HttpTransportType[endpoint.transport]));\r\n\r\n                    if (this._connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this._logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new AbortError(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private _constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this._options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent!, this._options.WebSocket, this._options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this._options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this._httpClient, this._logger, this._options);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private _startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this._stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private _resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this._logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this._options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\r\n                        this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`, transport);\r\n                    } else {\r\n                        this._logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this._constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this._logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`, transport);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private _stopConnection(error?: Error): void {\r\n        this._logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this._stopError || error;\r\n        this._stopError = undefined;\r\n\r\n        if (this._connectionState === ConnectionState.Disconnected) {\r\n            this._logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Connecting) {\r\n            this._logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this._connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this._stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this._logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this._logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this._sendQueue) {\r\n            this._sendQueue.stop().catch((e) => {\r\n                this._logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this._sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this._connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this._connectionStarted) {\r\n            this._connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this._logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this._logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private _resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private _buffer: any[] = [];\r\n    private _sendBufferedData: PromiseSource;\r\n    private _executing: boolean = true;\r\n    private _transportResult?: PromiseSource;\r\n    private _sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly _transport: ITransport) {\r\n        this._sendBufferedData = new PromiseSource();\r\n        this._transportResult = new PromiseSource();\r\n\r\n        this._sendLoopPromise = this._sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this._bufferData(data);\r\n        if (!this._transportResult) {\r\n            this._transportResult = new PromiseSource();\r\n        }\r\n        return this._transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this._executing = false;\r\n        this._sendBufferedData.resolve();\r\n        return this._sendLoopPromise;\r\n    }\r\n\r\n    private _bufferData(data: string | ArrayBuffer): void {\r\n        if (this._buffer.length && typeof(this._buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this._buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this._buffer.push(data);\r\n        this._sendBufferedData.resolve();\r\n    }\r\n\r\n    private async _sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this._sendBufferedData.promise;\r\n\r\n            if (!this._executing) {\r\n                if (this._transportResult) {\r\n                    this._transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this._sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this._transportResult!;\r\n            this._transportResult = undefined;\r\n\r\n            const data = typeof(this._buffer[0]) === \"string\" ?\r\n                this._buffer.join(\"\") :\r\n                TransportSendQueue._concatBuffers(this._buffer);\r\n\r\n            this._buffer.length = 0;\r\n\r\n            try {\r\n                await this._transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private _resolver?: () => void;\r\n    private _rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this._resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this._rejecter!(reason);\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { CompletionMessage, HubMessage, IHubProtocol, InvocationMessage, MessageType, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { TextMessageFormat } from \"./TextMessageFormat\";\r\n\r\nconst JSON_HUB_PROTOCOL_NAME: string = \"json\";\r\n\r\n/** Implements the JSON Hub Protocol. */\r\nexport class JsonHubProtocol implements IHubProtocol {\r\n\r\n    /** @inheritDoc */\r\n    public readonly name: string = JSON_HUB_PROTOCOL_NAME;\r\n    /** @inheritDoc */\r\n    public readonly version: number = 1;\r\n\r\n    /** @inheritDoc */\r\n    public readonly transferFormat: TransferFormat = TransferFormat.Text;\r\n\r\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\r\n     *\r\n     * @param {string} input A string containing the serialized representation.\r\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\r\n     */\r\n    public parseMessages(input: string, logger: ILogger): HubMessage[] {\r\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\r\n        if (typeof input !== \"string\") {\r\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\r\n        }\r\n\r\n        if (!input) {\r\n            return [];\r\n        }\r\n\r\n        if (logger === null) {\r\n            logger = NullLogger.instance;\r\n        }\r\n\r\n        // Parse the messages\r\n        const messages = TextMessageFormat.parse(input);\r\n\r\n        const hubMessages = [];\r\n        for (const message of messages) {\r\n            const parsedMessage = JSON.parse(message) as HubMessage;\r\n            if (typeof parsedMessage.type !== \"number\") {\r\n                throw new Error(\"Invalid payload.\");\r\n            }\r\n            switch (parsedMessage.type) {\r\n                case MessageType.Invocation:\r\n                    this._isInvocationMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.StreamItem:\r\n                    this._isStreamItemMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Completion:\r\n                    this._isCompletionMessage(parsedMessage);\r\n                    break;\r\n                case MessageType.Ping:\r\n                    // Single value, no need to validate\r\n                    break;\r\n                case MessageType.Close:\r\n                    // All optional values, no need to validate\r\n                    break;\r\n                default:\r\n                    // Future protocol changes can add message types, old clients can ignore them\r\n                    logger.log(LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\r\n                    continue;\r\n            }\r\n            hubMessages.push(parsedMessage);\r\n        }\r\n\r\n        return hubMessages;\r\n    }\r\n\r\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\r\n     *\r\n     * @param {HubMessage} message The message to write.\r\n     * @returns {string} A string containing the serialized representation of the message.\r\n     */\r\n    public writeMessage(message: HubMessage): string {\r\n        return TextMessageFormat.write(JSON.stringify(message));\r\n    }\r\n\r\n    private _isInvocationMessage(message: InvocationMessage): void {\r\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\r\n\r\n        if (message.invocationId !== undefined) {\r\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\r\n        }\r\n    }\r\n\r\n    private _isStreamItemMessage(message: StreamItemMessage): void {\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\r\n\r\n        if (message.item === undefined) {\r\n            throw new Error(\"Invalid payload for StreamItem message.\");\r\n        }\r\n    }\r\n\r\n    private _isCompletionMessage(message: CompletionMessage): void {\r\n        if (message.result && message.error) {\r\n            throw new Error(\"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        if (!message.result && message.error) {\r\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\r\n        }\r\n\r\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\r\n    }\r\n\r\n    private _assertNotEmptyString(value: any, errorMessage: string): void {\r\n        if (typeof value !== \"string\" || value === \"\") {\r\n            throw new Error(errorMessage);\r\n        }\r\n    }\r\n}\r\n", "// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { DefaultReconnectPolicy } from \"./DefaultReconnectPolicy\";\r\nimport { HttpConnection } from \"./HttpConnection\";\r\nimport { HubConnection } from \"./HubConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { IHubProtocol } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { HttpTransportType } from \"./ITransport\";\r\nimport { JsonHubProtocol } from \"./JsonHubProtocol\";\r\nimport { NullLogger } from \"./Loggers\";\r\nimport { Arg, ConsoleLogger } from \"./Utils\";\r\n\r\nconst LogLevelNameMapping: {[k: string]: LogLevel} = {\r\n    trace: LogLevel.Trace,\r\n    debug: LogLevel.Debug,\r\n    info: LogLevel.Information,\r\n    information: LogLevel.Information,\r\n    warn: LogLevel.Warning,\r\n    warning: LogLevel.Warning,\r\n    error: LogLevel.Error,\r\n    critical: LogLevel.Critical,\r\n    none: LogLevel.None,\r\n};\r\n\r\nfunction parseLogLevel(name: string): LogLevel {\r\n    // Case-insensitive matching via lower-casing\r\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\r\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\r\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\r\n    if (typeof mapping !== \"undefined\") {\r\n        return mapping;\r\n    } else {\r\n        throw new Error(`Unknown log level: ${name}`);\r\n    }\r\n}\r\n\r\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\r\nexport class HubConnectionBuilder {\r\n    /** @internal */\r\n    public protocol?: IHubProtocol;\r\n    /** @internal */\r\n    public httpConnectionOptions?: IHttpConnectionOptions;\r\n    /** @internal */\r\n    public url?: string;\r\n    /** @internal */\r\n    public logger?: ILogger;\r\n\r\n    /** If defined, this indicates the client should automatically attempt to reconnect if the connection is lost. */\r\n    /** @internal */\r\n    public reconnectPolicy?: IRetryPolicy;\r\n\r\n    /** Configures console logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel} logLevel The minimum level of messages to log. Anything at this level, or a more severe level, will be logged.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logLevel: LogLevel): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {ILogger} logger An object implementing the {@link @microsoft/signalr.ILogger} interface, which will be used to write all log messages.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logger: ILogger): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {string} logLevel A string representing a LogLevel setting a minimum level of messages to log.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     */\r\n    public configureLogging(logLevel: string): HubConnectionBuilder;\r\n\r\n    /** Configures custom logging for the {@link @microsoft/signalr.HubConnection}.\r\n     *\r\n     * @param {LogLevel | string | ILogger} logging A {@link @microsoft/signalr.LogLevel}, a string representing a LogLevel, or an object implementing the {@link @microsoft/signalr.ILogger} interface.\r\n     *    See {@link https://docs.microsoft.com/aspnet/core/signalr/configuration#configure-logging|the documentation for client logging configuration} for more details.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder;\r\n    public configureLogging(logging: LogLevel | string | ILogger): HubConnectionBuilder {\r\n        Arg.isRequired(logging, \"logging\");\r\n\r\n        if (isLogger(logging)) {\r\n            this.logger = logging;\r\n        } else if (typeof logging === \"string\") {\r\n            const logLevel = parseLogLevel(logging);\r\n            this.logger = new ConsoleLogger(logLevel);\r\n        } else {\r\n            this.logger = new ConsoleLogger(logging);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * The transport will be selected automatically based on what the server and client support.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified HTTP-based transport to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {HttpTransportType} transportType The specific transport to use.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, transportType: HttpTransportType): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use HTTP-based transports to connect to the specified URL.\r\n     *\r\n     * @param {string} url The URL the connection will use.\r\n     * @param {IHttpConnectionOptions} options An options object used to configure the connection.\r\n     * @returns The {@link @microsoft/signalr.HubConnectionBuilder} instance, for chaining.\r\n     */\r\n    public withUrl(url: string, options: IHttpConnectionOptions): HubConnectionBuilder;\r\n    public withUrl(url: string, transportTypeOrOptions?: IHttpConnectionOptions | HttpTransportType): HubConnectionBuilder {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isNotEmpty(url, \"url\");\r\n\r\n        this.url = url;\r\n\r\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\r\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\r\n        if (typeof transportTypeOrOptions === \"object\") {\r\n            this.httpConnectionOptions = { ...this.httpConnectionOptions, ...transportTypeOrOptions };\r\n        } else {\r\n            this.httpConnectionOptions = {\r\n                ...this.httpConnectionOptions,\r\n                transport: transportTypeOrOptions,\r\n            };\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\r\n     *\r\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\r\n     */\r\n    public withHubProtocol(protocol: IHubProtocol): HubConnectionBuilder {\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.protocol = protocol;\r\n        return this;\r\n    }\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     * By default, the client will wait 0, 2, 10 and 30 seconds respectively before trying up to 4 reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {number[]} retryDelays An array containing the delays in milliseconds before trying each reconnect attempt.\r\n     * The length of the array represents how many failed reconnect attempts it takes before the client will stop attempting to reconnect.\r\n     */\r\n    public withAutomaticReconnect(retryDelays: number[]): HubConnectionBuilder;\r\n\r\n    /** Configures the {@link @microsoft/signalr.HubConnection} to automatically attempt to reconnect if the connection is lost.\r\n     *\r\n     * @param {IRetryPolicy} reconnectPolicy An {@link @microsoft/signalR.IRetryPolicy} that controls the timing and number of reconnect attempts.\r\n     */\r\n    public withAutomaticReconnect(reconnectPolicy: IRetryPolicy): HubConnectionBuilder;\r\n    public withAutomaticReconnect(retryDelaysOrReconnectPolicy?: number[] | IRetryPolicy): HubConnectionBuilder {\r\n        if (this.reconnectPolicy) {\r\n            throw new Error(\"A reconnectPolicy has already been set.\");\r\n        }\r\n\r\n        if (!retryDelaysOrReconnectPolicy) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy();\r\n        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\r\n            this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\r\n        } else {\r\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\r\n     *\r\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\r\n     */\r\n    public build(): HubConnection {\r\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\r\n        // provided to configureLogger\r\n        const httpConnectionOptions = this.httpConnectionOptions || {};\r\n\r\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\r\n        if (httpConnectionOptions.logger === undefined) {\r\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\r\n            httpConnectionOptions.logger = this.logger;\r\n        }\r\n\r\n        // Now create the connection\r\n        if (!this.url) {\r\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\r\n        }\r\n        const connection = new HttpConnection(this.url, httpConnectionOptions);\r\n\r\n        return HubConnection.create(\r\n            connection,\r\n            this.logger || NullLogger.instance,\r\n            this.protocol || new JsonHubProtocol(),\r\n            this.reconnectPolicy);\r\n    }\r\n}\r\n\r\nfunction isLogger(logger: any): logger is ILogger {\r\n    return logger.log !== undefined;\r\n}\r\n"],
  "mappings": "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",
  "names": ["import_corelib", "HttpError", "errorMessage", "statusCode", "trueProto", "__name", "TimeoutError", "AbortError", "UnsupportedTransportError", "message", "transport", "DisabledTransportError", "FailedToStartTransportError", "FailedToNegotiateWithServerError", "AggregateErrors", "innerErrors", "HttpResponse", "statusCode", "statusText", "content", "__name", "HttpClient", "url", "options", "__spreadProps", "__spreadValues", "LogLevel", "NullLogger", "_logLevel", "_message", "__name", "VERSION", "Arg", "val", "name", "values", "__name", "Platform", "getDataDetail", "data", "includeContent", "detail", "isArrayBuffer", "formatArrayBuffer", "view", "str", "num", "pad", "sendMessage", "logger", "transportName", "httpClient", "url", "content", "options", "__async", "headers", "value", "getUserAgentHeader", "LogLevel", "responseType", "response", "__spreadValues", "createLogger", "ConsoleLogger", "NullLogger", "SubjectSubscription", "subject", "observer", "index", "_", "minimumLogLevel", "logLevel", "message", "msg", "userAgentHeaderName", "constructUserAgent", "getOsName", "getRuntime", "getRuntimeVersion", "version", "os", "runtime", "runtimeVersion", "userAgent", "majorAndMinor", "getErrorString", "e", "getGlobalThis", "FetchHttpClient", "HttpClient", "logger", "requireFunc", "__require", "getGlobalThis", "request", "__async", "AbortError", "abortController", "error", "timeoutId", "msTimeout", "LogLevel", "TimeoutError", "isArrayBuffer", "response", "__spreadValues", "e", "errorMessage", "deserializeContent", "HttpError", "payload", "HttpResponse", "url", "cookies", "Platform", "c", "__name", "responseType", "content", "XhrHttpClient", "HttpClient", "logger", "request", "AbortError", "resolve", "reject", "xhr", "isArrayBuffer", "headers", "header", "HttpResponse", "HttpError", "LogLevel", "TimeoutError", "__name", "DefaultHttpClient", "HttpClient", "logger", "Platform", "FetchHttpClient", "XhrHttpClient", "request", "AbortError", "url", "__name", "TextMessageFormat", "output", "input", "messages", "__name", "HandshakeProtocol", "handshakeRequest", "TextMessageFormat", "data", "messageData", "remainingData", "isArrayBuffer", "binaryData", "separatorIndex", "responseLength", "textData", "messages", "response", "__name", "MessageType", "Subject", "item", "observer", "err", "SubjectSubscription", "__name", "DEFAULT_TIMEOUT_IN_MS", "DEFAULT_PING_INTERVAL_IN_MS", "HubConnectionState", "HubConnection", "connection", "logger", "protocol", "reconnectPolicy", "LogLevel", "Arg", "HandshakeProtocol", "data", "error", "MessageType", "url", "__async", "Platform", "handshakePromise", "resolve", "reject", "handshakeRequest", "e", "startPromise", "AbortError", "methodName", "args", "streams", "streamIds", "invocationDescriptor", "promiseQueue", "subject", "Subject", "cancelInvocation", "invocationEvent", "message", "sendPromise", "newMethod", "method", "handlers", "removeIdx", "callback", "messages", "getErrorString", "responseMessage", "remainingData", "nextPing", "invocationMessage", "methods", "methodsCopy", "expectsResponse", "res", "exception", "completionMessage", "m", "prevRes", "c", "reconnectStartTime", "previousReconnectAttempts", "retryError", "nextRetryDelay", "previousRetryCount", "elapsedMilliseconds", "retryReason", "callbacks", "key", "nonblocking", "invocationId", "streamId", "err", "item", "i", "argument", "arg", "id", "result", "__name", "DEFAULT_RETRY_DELAYS_IN_MILLISECONDS", "DefaultReconnectPolicy", "retryDelays", "retryContext", "__name", "HeaderNames", "__name", "AccessTokenHttpClient", "HttpClient", "innerClient", "accessTokenFactory", "request", "__async", "allowRetry", "response", "HeaderNames", "url", "__name", "HttpTransportType", "TransferFormat", "AbortController", "__name", "LongPollingTransport", "httpClient", "logger", "options", "AbortController", "url", "transferFormat", "__async", "Arg", "TransferFormat", "LogLevel", "name", "value", "getUserAgentHeader", "headers", "__spreadValues", "pollOptions", "pollUrl", "response", "HttpError", "getDataDetail", "e", "TimeoutError", "data", "sendMessage", "deleteOptions", "logMessage", "__name", "ServerSentEventsTransport", "httpClient", "accessToken", "logger", "options", "url", "transferFormat", "__async", "Arg", "TransferFormat", "LogLevel", "resolve", "reject", "opened", "eventSource", "Platform", "cookies", "headers", "name", "value", "getUserAgentHeader", "__spreadValues", "e", "getDataDetail", "error", "data", "sendMessage", "__name", "WebSocketTransport", "httpClient", "accessTokenFactory", "logger", "logMessageContent", "webSocketConstructor", "headers", "url", "transferFormat", "__async", "Arg", "TransferFormat", "LogLevel", "token", "resolve", "reject", "webSocket", "cookies", "opened", "Platform", "name", "value", "getUserAgentHeader", "HeaderNames", "__spreadValues", "_event", "event", "error", "message", "getDataDetail", "data", "__name", "MAX_REDIRECTS", "HttpConnection", "url", "options", "Arg", "createLogger", "webSocketModule", "eventSourceModule", "Platform", "__require", "requireFunc", "AccessTokenHttpClient", "DefaultHttpClient", "transferFormat", "__async", "TransferFormat", "LogLevel", "message", "AbortError", "data", "TransportSendQueue", "error", "resolve", "e", "HttpTransportType", "negotiateResponse", "redirects", "accessToken", "LongPollingTransport", "headers", "name", "value", "getUserAgentHeader", "negotiateUrl", "response", "__spreadValues", "errorMessage", "HttpError", "FailedToNegotiateWithServerError", "connectionToken", "requestedTransport", "requestedTransferFormat", "connectUrl", "transportExceptions", "transports", "negotiate", "endpoint", "transportOrError", "ex", "FailedToStartTransportError", "AggregateErrors", "transport", "WebSocketTransport", "ServerSentEventsTransport", "transportMatches", "s", "UnsupportedTransportError", "DisabledTransportError", "aTag", "index", "__name", "actualTransport", "_transport", "PromiseSource", "transportResult", "arrayBuffers", "totalLength", "b", "a", "result", "offset", "item", "reject", "reason", "JSON_HUB_PROTOCOL_NAME", "JsonHubProtocol", "TransferFormat", "input", "logger", "NullLogger", "messages", "TextMessageFormat", "hubMessages", "message", "parsedMessage", "MessageType", "LogLevel", "value", "errorMessage", "__name", "LogLevelNameMapping", "LogLevel", "parseLogLevel", "name", "mapping", "__name", "HubConnectionBuilder", "logging", "Arg", "isLogger", "logLevel", "ConsoleLogger", "url", "transportTypeOrOptions", "__spreadValues", "__spreadProps", "protocol", "retryDelaysOrReconnectPolicy", "DefaultReconnectPolicy", "httpConnectionOptions", "connection", "HttpConnection", "HubConnection", "NullLogger", "JsonHubProtocol", "logger", "DashboardPanel", "container", "HubConnectionBuilder", "data", "err", "__name"]
}
